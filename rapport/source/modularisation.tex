\section{Modularisation}
\label{sec:module}

\subsection{Threading}
Afin de préparer la séparation sur plusieurs machines (une se chargeant d'éxecuter le moteur: le serveur, et l'autre gérant le rendu: le client) et d'optimiser l'éxecution du jeu, nous allons séparer notre jeu en deux threads. Alors que le thread principal sera responsable du rendu graphique du jeu, le second se chargera de gérer le rendu.

Afin de ne pas afficher une ressource qui est en cours de modification, nous utilisons un mutex, ce qui permet que les parties critiques du code ne soient pas utilisées en meme temps par plusieurs threads séparés. De plus, La communication entre les threads se fait par le biais de pointeurs vers des booléens et vers l'état du jeu. Lors de la mise en réseau du jeu, la communication se fera par l'intermédiaire de fichiers Json.

\subsection{Record/Replay}
Lors de la fonction \textit{update} du moteur, on ajoute la sérialisation des commandes à une Json::Value \textit{jsonval}. Cette Json::Value est enregistrée dans le fichier \textit{replay.txt} lors de l'appel du destructeur du moteur. On enregistre également une seed pour la fonction rand() utilisée dans le jeu.
Afin d'enregister les commandes dans le fichier, on ajoute deux méthodes aux commandes: \textit{Serialize} et \textit{Deserialize}.
\par \textbf{Serialize:} défini et retourne une Json::Value \textit{val}. On ajoute à val tous les attribus nécessaires à la création d'une commande (par exemple, \textit{entityID} pour la plupart des commandes). On ajoute également un champ commun à toutes les commandes: \textit{typeCmd} qui définit le type de la commande sérialisée.
\par \textbf{Deserialize:} à partir d'une Json::Value \textit{in}, on désérialise une commande. On reprend tous les arguments correspondant à la commande pour les mettre dans les champs correspondants. Puis on renvoie la commande ainsi initialisée.

On ajoute une méthode \textit{ReadCommand} au moteur afin de lire toutes les commandes du fichier replay.txt. 

\par \textbf{ReadCommand:} prend une Json::Value \textit{val} en entrée. Décompose val en différentes commandes. On analyse le champ "typeCmd" afin de désérialiser la commande correspondante, les attributs variant d'une commande à l'autre. On enregistre toutes les commandes ainsi re-créées dans le vecteur de commandes du moteur, qui les réalisera à l'aide de sa fonction "update".



\clearpage
\subsection{Conception logiciel}


%
%\begin{landscape}
%\begin{figure}[p]
%\includegraphics[width=0.9\paperheight]{module.pdf}
%\caption{\label{uml:module}Diagramme des classes pour la modularisation.} 
%\end{figure}
%\end{landscape}
